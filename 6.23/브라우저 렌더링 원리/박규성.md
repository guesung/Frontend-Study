# 브라우저 동작 방법

## 브라우저 주요 기능

- 사용자가 선택한 자원을 서버에 요청 -> 브라우저에 표시
  - 자원 : html 문서, pdf, image 등 다양한 형태
  - 자원의 주소는 URI에 의해 정해짐
- 브라우저는 html과 css명세에 따라 html 파일을 해석하고 표시
  - 이 명세는 웹 표준화 기구인 W3C(World Widw Web Consortium)에서 정함

## 브라우저 기본 구조

<img src='https://d2.naver.com/content/images/2015/06/helloworld-59361-1.png' width='400' />

- 사용자 인터페이스 : 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등 사용자가 활용하는 서비스들
- 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어
- 렌더링 엔진 : 요청한 콘텐츠 표시 (html 요청이 들어오면? → html, css 파싱해서 화면에 표시)
- 통신 : http 요청과 같은 네트워크 호출에 사용 (플랫폼의 독립적인 인터페이스로 구성되어있음)
- UI 백엔드 : 플랫폼에서 명시하지 않은 일반적 인터페이스. 콤보 박스 창같은 기본적 장치를 그림
- 자바스크립트 해석기 : 자바스크립트 코드를 해석하고 실행
- 자료 저장소 : 쿠키 등 모든 종류의 자원을 하드 디스크에 저장하는 계층

## 렌더링이란?

- 렌더링 : HTML 파일을 받아 브라우저에 뿌려주는 과정
- 렌더링 엔진
  - HTML 문서를 파싱하여 DOM트리를 생성
  - CSS 파일과 함께 포함된 스타일 요소를 파싱하여 CSSOM트리 생성

### 렌더링 동작 과정

1. html파싱하여 DOM 트리 구축
2. html 파싱 도중 CSS파일을 로드하는 `<link />`, `<style />`을 만나면 CSS파일을 서버에 요청하고, 이 CSS파일을 파싱하여 CSSOM트리생성
   - html파싱과 css파싱은 비동기적으로 실행
   - CSS관련 `<link />`나 `<style />`은 꼭 html문서의 상단에 위치시키는 것이 좋음 : 하단에 위치시키면 CSS파싱이 늦어져 빈 골격의 화면이 먼저 보이게 됨
3. html 파싱 도중 `<script />`를 만나면 2번과 달리 동기적으로(html 파싱을 멈추고) 스크립트 다운로드
   - 로딩이 오래걸리는 스크립트, 혹은 html 요소에 접근하는 코드가 있는 스크립트는 body의 닫는 태그 바로 위에 위치
   - 혹은 `defer`,`async` 속성을 사용하여 비동기적으로 수행
     - `defer` : 스크립트 로딩이 완료 되어도 html 파싱이 끝날 떄까지 기다린 후 스크립트 실행
     - `async` : 스크립트가 로딩되면 바로 스크립트를 실행. html요소에 접근하는 코드가 있는데, 그 html요소가 아직 파싱되지 않았다면 에러 발생
     - html 요소에 접근할 일이 없고, 독립적으로 수행되어야 하는 스크립트는 `async`, 모든 html문서가 로딩된 후 실행되어야 하는 스크립트는 `defer`사용
4. DOM 트리와 스타일 구조체를 결합하여 렌더 트리 생성

   - 렌더 트리 : 브라우저가 화면에 표시하기 위해 계산한 최종 결과물
   - 보이지 않는 요소(html,head,meta, `display:none`속성의 요소)는 포함 x

5. 레이아웃 (=리플로우,`reflow`) : 기기의 뷰포트 내에서 노드들의 정확한 위치와 크기를 계산
6. 렌더링 트리의 루트부터 시작하여 렌더링 트리를 순회 -> 페이지의 각 객체의 정확한 크기와 위치 파악
7. 페인팅 : 렌더링 엔진은 페이지 이벤트를 발생시켜 렌더링 트리를 화면에 그림

- 모든 HTML을 파싱할 떄까지 기다리지 않고 배치와 그리기 과정을 진행. 웹 페이지에 접속했을 때 페이지가 한꺼번에 뜨지 않고 점점 화면에 그려지는 것이 이 때문

### 리플로우와 리페인트

1. 리플로우(Reflow,=레이아웃) : DOM 요소의 기하학적 속성이 변경될 때, 브라우저 사이즈가 변할 때, 스타일시트가 로딩되었을 때 발생하는 변화들을 다시 계산해주는 작업
   - 변화된 요소 주변의 모든 요소(부모, 자식, 형제)들도 영향을 받게되는데 결국 DOM요소 하나의 시각적 변화가 DOM트리 전체에 다시 계산을 수행하게 함
2. 리페인트(Repaint) : 변경된 요소를 실제로 화면에 그려주는 작업
   - 리플로우 발생 시 필연적으로 리페인트 발생
   - 모든 요소에 대한 기하학적 정보를 계산해주는 리페인트에 비해 리플로우는 비교적 가벼운 작업
   - 레이아웃이 변경되지 않고 스타일만 변경되었을 때 리페인트만 발생 e.g.`opacity`,`background-color`, `display:none`

- 레이아웃이 변경 : 리플로우 > 리페인팅
  - DOM 엘리먼트 추가/제거/변경
  - CSS 스타일 추가/제거/변경
- `display:none`, `visibility:hidden`의 차이점
  - `display:none` : 보이지도 않고, 영역도 차하지 않음. 리플로우와 리페인트 발생(영역이 없어지며 다른 요소들이 공간을 밀고 옴)
  - `visibility:hidden` : 화면에서 보이진 않아도 그 영역을 그대로 차지. 리페인트만 발생

### 리플로우 최적화 방법

1. 인라인 스타일 사용 X : 인라인 스타일은 DOM 엘리먼트에 직접 스타일을 적용하는 것이기 때문에 DOM 엘리먼트의 스타일을 변경하면 리플로우가 발생
2. 작업 그루핑 : DOM 엘리먼트를 추가하거나 제거할 때, 가능하면 한 번에 처리하는 것이 좋음
3. 노출 제어 : `display:none`으로 엘리먼트를 숨기는 것은 리플로우를 발생시키지 않음

##### # 어태치먼트 : 웹킷이 렌더 트리를 생성하기 위해 DOM 노드와 스타일 정보를 연결하는 과정

##### # 문서 파싱 : 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것

### DOM이란?

Document Object Model(문서 객체 모델) : \<html>,\<body> 등과 같은 태그들을 JS가 활용할 수 있는 객체로 만든 것
즉, 웹 브라우저가 html 페이지를 인식하는 방식

### 출처

- [브라우저 동작 방법](https://gyoogle.dev/blog/web-knowledge/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%20%EB%8F%99%EC%9E%91%20%EB%B0%A9%EB%B2%95.html)
- [렌더링이란](https://velog.io/@ru_bryunak/%EB%A0%8C%EB%8D%94%EB%A7%81%EC%9D%B4%EB%9E%80)
- [브라우저 렌더링 - 리플로우(reflow) 와 리페인트(repaint)](https://kwangsunny.tistory.com/42)
